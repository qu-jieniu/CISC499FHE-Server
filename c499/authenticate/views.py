# Django
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth import authenticate,login as auth_login,logout as auth_logout
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User

# DRF 
from rest_framework import status
from rest_framework.authtoken.models import Token 
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

# DRF_simplejwt
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenObtainPairView

# Project
from .serializers import AuthUserSerializer,MyTokenObtainPairSerializer
from utils.utils import *

# Misc
import base64
from datetime import datetime
from hashlib import sha1,sha256
import json
import jwt as jwt_utils
import logging

# open configfile for secret key
with open('etc\config.json','r') as config_file:
    config = json.load(config_file)

# get logger instance
logger = logging.getLogger('c499.logger') 

# signup route is generic authentication route
# can be substituted for any method, used here
# for simple entry point to server
@api_view(['POST'])
def signup(request):
    status_message = {}

    if request.method == 'POST':
        # create user form from posted authentication info
        form = UserCreationForm(request.POST)

        # validate form (check if passwords match, etc.)
        if form.is_valid():
            # create user for submitted data
            form.save()

            # get clean info
            username = form.cleaned_data.get('username')
            raw_password = form.cleaned_data.get('password1')
            
            # authenticate user
            user = authenticate(username=username, password=raw_password)
            
            # login 
            auth_login(request, user)
            
            # attempt to get autogenerated token
            try:
                device = Token.objects.get(user=user)
            except Token.DoesNotExist:
                logger.critical("token: "+str("token not autogenerated on user creation"))
                status_message["critical_error"] = "token not created on signup"
                return Response(status_message,status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            except Exception as err:
                logger.critical("unknown: " + str(err))
                status_message["unknown_error"] = err
                return Response(status_message,status=status.HTTP_500_INTERNAL_SERVER_ERROR) 
            
            # return token generated for user
            status_message["token"] = device.key
            return Response(status_message,status=status.HTTP_200_OK)
        else:
            status_message["auth_error"] = form.errors 
            return Response(status_message,status=status.HTTP_400_BAD_REQUEST)
    else:
        return Response(status=status.HTTP_405_METHOD_NOT_ALLOWED)

# function that generates token when it receives a signal
# that a user has been generated
@receiver(post_save,sender=settings.AUTH_USER_MODEL)
def create_auth_token(sender,instance=None,created=False,**kwargs):
    if created:
        Token.objects.create(user=instance)

# generic log-in route, returns token
@api_view(['POST'])
def login(request):
    status_message = {}
    if request.method == 'POST':   
        username = request.POST['username']
        password = request.POST['password']

        # authenticate against auth backend    
        user = authenticate(request,username=username,password=password) 
        
        # authenticate() returns None if invalid
        if user is not None:
            auth_login(request,user)
            try:
                device = Token.objects.get(user=user)
            except Token.DoesNotExist:
                logger.critical("token: user does not have token")
                status_message["critical_error"] = "user does not have token"
                return Response(status_message,status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            except Exception as err:
                logger.critical("unknown: "+str(err))
                status_message["unknown_error"] = err
                return Response(status_message,status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            
            # return token 
            status_message["token"] = device.key
            return Response(status_message,status=status.HTTP_200_OK)
        else:
            status_message["authError"] = "bad login"
            return Response(status_message,status=status.HTTP_401_UNAUTHORIZED) 
    else:
        return Response(status=status.HTTP_405_METHOD_NOT_ALLOWED)

# logout route, leaves data in place
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def logout(request):
    status_message = {}
    if request.method == 'POST':   
        try:
            device = request.headers["Authorization"]
        except KeyError:
            status_message["authError"] = "device token not supplied"
            return Response(status_message,status=status.HTTP_401_UNAUTHORIZED)
        
        device = strip_token(device)

        try:
            token = Token.objects.get(key=device)
            user = User.objects.get(username=token.user)
        except (Token.DoesNotExist,User.DoesNotExist):
            status_message["authError"] = "invalid token"
            return Response(status_message,status=status.HTTP_401_UNAUTHORIZED)
        except Exception as err:
            status_message["serviceError"] = err
            return Response(status_message,status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        auth_logout(request)
            
        status_message["logout"] = "success"
        return Response(status_message,status=status.HTTP_200_OK)
         
    else:
        return Response(status=status.HTTP_405_METHOD_NOT_ALLOWED)

# logout route, deletes all data of current session
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def del_logout(request):
    status_message = {}
    if request.method == 'POST':   
        try:
            device = request.headers["Authorization"]
        except KeyError:
            status_message["authError"] = "how did you get past authentication?"
            return Response(status_message,status=status.HTTP_401_UNAUTHORIZED)
        
        try:
            session_id = request.cookies["sessionid"]
        except KeyError:
            status_message["authError"] = "session_id missing"
            return Response(status_message,status=status.HTTP_400_BAD_REQUEST)
        
        device = strip_token(device)

        try:
            token = Token.objects.get(key=device)
            user = User.objects.get(username=token.user)
            session = PersistentSession.objects.get(session_id=session_id)
        except (Token.DoesNotExist,User.DoesNotExist):
            status_message["authError"] = "invalid token"
            return Response(status_message,status=status.HTTP_401_UNAUTHORIZED)
        except PersistentSession.DoesNotExist:
            status_message["sessionError"] = "invalid session_id"
            return Response(status_message,status=status.HTTP_400_BAD_REQUEST)
        except Exception as err:
            status_message["serviceError"] = err
            return Response(status_message,status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        auth_logout(request)
        session.delete()

        status_message["logout"] = "success"
        return Response(status_message,status=status.HTTP_200_OK)
         
    else:
        return Response(status=status.HTTP_405_METHOD_NOT_ALLOWED)


# returns JWT access token, refresh was originally included, but does not
# work due to custom JWT fields
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def obtain_jwt_pair(request):
    status_message = {}
    if request.method == 'GET':
        stripped = strip_token(request.headers["Authorization"])
        
        try:
            user = Token.objects.get(key=stripped).user
        except Token.DoesNotExist:
            status_message["tokenError"] = "how did you get past authentication?"
            return Response(status_message,status.HTTP_401_UNAUTHORIZED)
        except Exception as err:
            status_message["databaseError"] = err
            return Response(status_message,status=status.HTTP_500_INTERNAL_SERVER_ERROR) 
        
        refresh = RefreshToken.for_user(user)
        
        try:
            secret_key = sha256(config['SECRET_KEY'].rstrip().encode('utf-8')).hexdigest()
            decodeJTW = jwt_utils.decode(str(refresh.access_token), secret_key, algorithms=["HS256"])
            decodeJTW['token'] = stripped
            encoded = jwt_utils.encode(decodeJTW, secret_key, algorithm="HS256")
        except Exception as err:
            status_message["jwtError"] = str(err)
            return Response(status_message,status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        status_message["access"] = str(encoded)
        return Response(status_message,status=status.HTTP_200_OK)
    else:
        return Response(status=status.HTTP_405_METHOD_NOT_ALLOWED)

